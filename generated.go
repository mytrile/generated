package generated

import (
	"bufio"
	"fmt"
	"os"
	"path"
	"regexp"
	"strings"
)

type FileBlob struct {
	Path      string
	Extension string
}

func IsGenerated(file_path string) bool {
	file_blob := &FileBlob{Path: file_path, Extension: path.Ext(file_path)}

	if file_blob.IsXCodeProjectFile() || file_blob.IsGeneratedNetDesignerFile() || file_blob.IsNodeModuleFile() || file_blob.IsComposerLockFile() {
		return true
	}

	file, _ := os.Open(file_blob.Path)

	scanner := bufio.NewScanner(file)
	coffee_script_score := 0

	for scanner.Scan() {
		line := scanner.Text()

		if file_blob.IsMinifiedFile(line) || file_blob.IsGeneratedPostscriptFile(line) || file_blob.IsGeneratedProtocolBufferFile(line) || file_blob.IsGeneratedJniHeaderFile(line) || file_blob.IsVCRCasseteFile(line) || file_blob.IsPEGJSGeneratedFile(line) {
			return true
		}
		coffee_script_score = coffee_script_score + file_blob.DetectCoffeeScriptFile(line)
	}

	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, "reading file:", err)
		return false
	}

	if coffee_script_score > 5 {
		return true
	}

	return false
}

func (f *FileBlob) IsXCodeProjectFile() bool {
	return f.gotProperExtension(".xib", ".nib", ".storyboard", ".pbxproj", ".xcworkspacedata", ".xcuserstate")
}

func (f *FileBlob) IsMinifiedFile(line string) bool {
	if f.gotProperExtension(".js", ".css") {
		return len(line) > 110
	} else {
		return false
	}
}

func (f *FileBlob) DetectCoffeeScriptFile(line string) int {

	if f.gotProperExtension(".js") {

		generated_by_regex := `^\/\/ Generated by CoffeeScript`
		match, _ := regexp.MatchString(generated_by_regex, line)

		if match {
			return 5
		}

		start_line := "'(function() {'"
		end_line := "}).call(this);"
		vars_regex := regexp.MustCompile(`(_fn|_i|_len|_ref|_results)`)
		functions_regex := regexp.MustCompile(`(__bind|__extends|__hasProp|__indexOf|__slice)`)

		switch {
		case start_line == line || end_line == line:
			return 1
		case len(vars_regex.FindAllString(line, -1)) > 0:
			return len(vars_regex.FindAllString(line, -1))
		case len(functions_regex.FindAllString(line, -1)) > 0:
			return 3 * len(functions_regex.FindAllString(line, -1))
		}

	} else {
		return 0
	}
	return 0
}

func (f *FileBlob) IsGeneratedNetDesignerFile() bool {
	regex := regexp.MustCompile(`\.designer\.cs$`)
	return regex.MatchString(f.Path)
}

func (f *FileBlob) IsPEGJSGeneratedFile(line string) bool {
	if f.gotProperExtension(".js") {
		return strings.Contains(line, "Generated by PEG.js")
	} else {
		return false
	}
}

func (f *FileBlob) IsGeneratedPostscriptFile(line string) bool {
	if f.gotProperExtension(".ps", ".eps") {
		regex := regexp.MustCompile(`%%Creator: (mpage|draw|ImageMagick)`)
		return regex.MatchString(line)
	} else {
		return false
	}
}

func (f *FileBlob) IsGeneratedProtocolBufferFile(line string) bool {
	if f.gotProperExtension(".py", ".java", ".h", ".cc", ".cpp") {
		return strings.Contains(line, "Generated by the protocol buffer compiler")
	} else {
		return false
	}
}

func (f *FileBlob) IsGeneratedJniHeaderFile(line string) bool {
	if f.gotProperExtension(".h") {
		return strings.Contains(line, "DO NOT EDIT THIS FILE - it is machine generated")
	} else {
		return false
	}
}

func (f *FileBlob) IsNodeModuleFile() bool {
	return strings.Contains(f.Path, "node_modules")
}

func (f *FileBlob) IsComposerLockFile() bool {
	return path.Base(f.Path) == "composer.lock"
}

func (f *FileBlob) IsVCRCasseteFile(line string) bool {
	if f.gotProperExtension(".yml") {
		return strings.Contains(line, "recorded_with: VCR")
	} else {
		return false
	}
}

func (f *FileBlob) gotProperExtension(extensions ...string) bool {
	for _, value := range extensions {
		if f.Extension == value {
			return true
		}
	}
	return false
}
